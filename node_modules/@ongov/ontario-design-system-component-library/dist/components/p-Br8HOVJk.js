import { p as proxyCustomElement, H, h } from './index.js';
import { a as validatePropExists } from './p-CNqFEifG.js';
import { C as ConsoleMessageClass } from './p-CJXRCL8b.js';
import { v as v4 } from './p-BF0_OXTe.js';

const ontarioHintTextCss =
	'.ontario-hint{color:#4d4d4d;display:inline-block;margin:0 0 1rem 0;width:100%;max-width:48rem}.ontario-hint p{margin-bottom:1rem}.ontario-hint p:first-of-type{margin-top:0}.ontario-hint p:last-of-type{margin-bottom:0}.ontario-hint a[x-apple-data-detectors]{color:inherit;cursor:none;text-decoration:none}';

const OntarioHintText = /*@__PURE__*/ proxyCustomElement(
	class OntarioHintText extends H {
		constructor() {
			super();
			this.__registerHost();
			this.__attachShadow();
		}
		get host() {
			return this;
		}
		/**
		 * The content type of the hint.
		 * If no prop is passed, it will default to a string.
		 * If the hint requires multiple lines or HTML, the `hintContentType` prop should be set to `html`.
		 */
		hintContentType = 'string';
		/**
		 * Text to display as the hint text statement.
		 *
		 * Setting the hint can be done using the host element textContent or through setting this property.  This property will take precedence.
		 *
		 * @example
		 * <ontario-hint-text hint="Override Hint Text">Hint Text</ontario-button>
		 *
		 * The resulting hint text will display `"Override Hint Text"`.
		 */
		hint;
		/*
		 * Used to establish a relationship between the hint text content and elements using aria-describedby. This is optional -  if no ID is provided, one will be generated.
		 */
		elementId;
		hintState;
		/**
		 * @part hint-text - The container for the hint text content. This part can be used to apply custom styles to the hint text.
		 */
		/**
		 * Watch for changes to the `hintContentType` prop for validation purposes.
		 * If none is provided, or the wrong type is provided, it will default to `string`.
		 */
		checkHintContentType() {
			if (this.hintContentType !== 'string' && this.hintContentType !== 'html') {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' hintContentType ')
					.addRegularText('for')
					.addMonospaceText(' <ontario-hint-text> ')
					.addRegularText('was not one of the permitted types. A default type of `string` will be applied.')
					.printMessage();
				return (this.hintContentType = 'string');
			}
			return this.hintContentType;
		}
		/*
		 * Watch for changes in the `hint` prop for validation purposes.
		 * If no `hint` prop is provided, the `hint` will be set to the host element textContent (if it exists).
		 */
		updateHintContent() {
			this.hintState = this.hint ?? this.host.textContent ?? '';
			this.validateHintContent(this.hintState);
		}
		/*
		 * Validate the `hint` and make sure the `hint` has a value.
		 * Log a warning if user doesn't input a value for the `hint` or element content.
		 */
		validateHintContent(newValue) {
			// If element content is not provided, check whether prop exists
			if (!this.host.textContent) {
				if (validatePropExists(newValue)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' hint ')
						.addRegularText('for')
						.addMonospaceText(' <ontario-hint-text> ')
						.addRegularText('was not provided')
						.printMessage();
				}
			}
		}
		getId() {
			return this.elementId ?? '';
		}
		/**
		 * This method returns the ontario-hint-text id. It is used to make sure the hint text and `aria-describedby` value of other form components match when the internal hint text props are used.
		 *
		 * @returns {Promise<string | undefined>} The ID of the hint text element, or undefined if no ID is set.
		 */
		async getHintTextId() {
			return this.elementId;
		}
		/**
		 * Set `hint` using internal component logic
		 */
		componentWillLoad() {
			this.updateHintContent();
			this.checkHintContentType();
			this.elementId = this.elementId ?? v4();
		}
		/**
		 * This helper is used to help load translations for any slots + text content passed in by the user.
		 */
		componentDidLoad() {
			const observer = new MutationObserver((mutations) => {
				mutations.forEach((mutation) => {
					if (mutation.type === 'attributes') {
						this.updateHintContent();
					}
				});
			});
			const options = { attributes: true };
			observer.observe(this.host, options);
		}
		render() {
			return this.hintContentType === 'string'
				? h('p', { part: 'hint-text', id: this.getId(), class: 'ontario-hint' }, this.hintState)
				: h('div', { id: this.getId(), class: 'ontario-hint', innerHTML: this.hintState });
		}
		static get watchers() {
			return {
				hintContentType: ['checkHintContentType'],
				hint: ['updateHintContent'],
			};
		}
		static get style() {
			return ontarioHintTextCss;
		}
	},
	[
		1,
		'ontario-hint-text',
		{
			hintContentType: [1025, 'hint-content-type'],
			hint: [1],
			elementId: [1025, 'element-id'],
			hintState: [32],
			getHintTextId: [64],
		},
		undefined,
		{
			hintContentType: ['checkHintContentType'],
			hint: ['updateHintContent'],
		},
	],
);
function defineCustomElement() {
	if (typeof customElements === 'undefined') {
		return;
	}
	const components = ['ontario-hint-text'];
	components.forEach((tagName) => {
		switch (tagName) {
			case 'ontario-hint-text':
				if (!customElements.get(tagName)) {
					customElements.define(tagName, OntarioHintText);
				}
				break;
		}
	});
}

export { OntarioHintText as O, defineCustomElement as d };
//# sourceMappingURL=p-Br8HOVJk.js.map

//# sourceMappingURL=p-Br8HOVJk.js.map
