import { p as proxyCustomElement, H, h } from './index.js';
import { C as ConsoleMessageClass } from './p-CJXRCL8b.js';
import { v as validateValueAgainstArray, b as validateLanguage } from './p-CNqFEifG.js';
import { t as translations } from './p-DgMhpSmi.js';
import { T as TaskStatuses } from './p-A8xwC5QP.js';

const ontarioTaskListCss =
	'.ontario-task-list{border-top:0.125rem solid #cccccc;padding:0}.ontario-task-list__item{max-width:100%;list-style-type:none}';

const OntarioTaskList$1 = /*@__PURE__*/ proxyCustomElement(
	class OntarioTaskList extends H {
		constructor() {
			super();
			this.__registerHost();
			this.__attachShadow();
		}
		get el() {
			return this;
		}
		/**
		 * The label prop used for the task list heading.
		 */
		label;
		/**
		 * Allows consumers to define the heading level for the task list component.
		 *
		 * Accepts 'h1', 'h2', 'h3' or 'h4'. Default is 'h2'.
		 */
		headingLevel = 'h2';
		/**
		 * The language of the component.
		 * This is used for translations, and is by default set through event listeners checking for a language property from the header. If none are passed, it will default to English.
		 */
		language = 'en';
		/**
		 * State to track the number of completed tasks.
		 */
		completedTasks = 0;
		/**
		 * State to track the total number of tasks.
		 */
		totalTasks = 0;
		/**
		 * Class-level constant for task count delay in milliseconds.
		 *
		 * This delay ensures that the `ontario-task` custom elements are fully upgraded and rendered
		 * in the DOM before the `countTasks` method is executed. Without this delay, the component
		 * might attempt to query or count tasks before they are properly initialized, leading to
		 * inaccurate task counts.
		 */
		static TASK_COUNT_DELAY_MS = 50;
		/**
		 * Watch for changes in `headingLevel` prop to validate its value.
		 */
		validateHeadingLevel(newValue) {
			const allowedValues = ['h1', 'h2', 'h3', 'h4', 'h5'];
			// Validate the new value against the allowed values
			const isValid = validateValueAgainstArray(newValue, allowedValues);
			if (!isValid) {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' headingLevel ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-task-list> ')
					.addRegularText('was set to an invalid value; only ')
					.addMonospaceText(allowedValues.join(', '))
					.addRegularText(' are supported. The default value ')
					.addMonospaceText('h2')
					.addRegularText(' is assumed.')
					.printMessage();
				this.headingLevel = 'h2';
			}
		}
		/**
		 * Counts the total tasks and completed tasks by querying for `ontario-task` elements.
		 */
		countTasks() {
			const slot = this.el.shadowRoot?.querySelector('slot');
			const tasks = slot ? slot.assignedElements().filter((el) => el.tagName.toLowerCase() === 'ontario-task') : [];
			this.totalTasks = tasks.length;
			this.completedTasks = tasks.filter((task) => {
				// Get the status directly from the light DOM
				const status = task.getAttribute('data-task-status');
				return status === TaskStatuses.Completed;
			}).length;
		}
		/**
		 * Lifecycle method: before the component loads, validate heading level.
		 */
		async componentWillLoad() {
			this.validateHeadingLevel(this.headingLevel);
		}
		/**
		 * Ensure tasks are counted after custom elements are fully upgraded.
		 */
		connectedCallback() {
			// Wait for the custom element to be fully defined before counting
			customElements.whenDefined('ontario-task').then(() => {
				setTimeout(() => {
					this.countTasks();
				}, OntarioTaskList.TASK_COUNT_DELAY_MS);
			});
		}
		/**
		 * Use slotchange and MutationObserver to track changes in slot content.
		 */
		componentDidLoad() {
			const slot = this.el.shadowRoot?.querySelector('slot');
			if (slot) {
				slot.addEventListener('slotchange', () => {
					this.countTasks();
				});
			}
			// Observe changes to the light DOM for accurate counting
			const observer = new MutationObserver((_mutations) => {
				this.countTasks();
			});
			observer.observe(this.el, {
				childList: true,
				subtree: true,
				attributes: true,
				attributeFilter: ['data-task-status'],
			});
		}
		componentDidRender() {
			setTimeout(() => {
				this.countTasks();
			}, OntarioTaskList.TASK_COUNT_DELAY_MS);
		}
		render() {
			// Resolve the language to ensure valid translations are used.
			const resolvedLanguage = validateLanguage(this.language);
			const headingProps = {
				class: { 'ontario-task-list__heading': true },
			};
			return h(
				'div',
				{ key: 'fb26534c596025f0bbbf729d923210760e31ff60', class: 'ontario-task-list__container' },
				h(this.headingLevel, headingProps, this.label),
				h(
					'p',
					{
						'key': '8344876cd43f5b4c06685a41d0f49a55817cb1ee',
						'class': 'ontario-task-list__completion-text',
						'aria-live': 'polite',
					},
					translations.taskGroup.completed[resolvedLanguage],
					'\u00A0',
					this.completedTasks,
					'\u00A0',
					translations.taskGroup.outOf[resolvedLanguage],
					'\u00A0',
					this.totalTasks,
					'\u00A0',
					translations.taskGroup.tasks[resolvedLanguage],
				),
				h(
					'ul',
					{ key: '42962ee4027bf4df1309ef409106e040f98c5fd2', class: 'ontario-task-list', role: 'list' },
					h('slot', { key: 'd226bd26241b20557f13a0acdb161ae474c915e1' }),
				),
			);
		}
		static get watchers() {
			return {
				headingLevel: ['validateHeadingLevel'],
			};
		}
		static get style() {
			return ontarioTaskListCss;
		}
	},
	[
		1,
		'ontario-task-list',
		{
			label: [1],
			headingLevel: [1, 'heading-level'],
			language: [1025],
			completedTasks: [32],
			totalTasks: [32],
		},
		undefined,
		{
			headingLevel: ['validateHeadingLevel'],
		},
	],
);
function defineCustomElement$1() {
	if (typeof customElements === 'undefined') {
		return;
	}
	const components = ['ontario-task-list'];
	components.forEach((tagName) => {
		switch (tagName) {
			case 'ontario-task-list':
				if (!customElements.get(tagName)) {
					customElements.define(tagName, OntarioTaskList$1);
				}
				break;
		}
	});
}

const OntarioTaskList = OntarioTaskList$1;
const defineCustomElement = defineCustomElement$1;

export { OntarioTaskList, defineCustomElement };
//# sourceMappingURL=ontario-task-list.js.map

//# sourceMappingURL=ontario-task-list.js.map
