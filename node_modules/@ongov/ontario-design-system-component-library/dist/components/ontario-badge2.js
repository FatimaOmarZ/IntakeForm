import { proxyCustomElement, HTMLElement, h } from '@stencil/core/internal/client';
import { r as retrieveEnumKeys } from './utils.js';
import { C as ConsoleMessageClass } from './console-message.js';
import { a as validateValueAgainstArray } from './validation-functions.js';

var BadgeColourToClass;
(function (BadgeColourToClass) {
	BadgeColourToClass['teal'] = 'ontario-badge--default-heavy';
	BadgeColourToClass['lightTeal'] = 'ontario-badge--default-light';
	BadgeColourToClass['black'] = 'ontario-badge--neutral-heavy';
	BadgeColourToClass['grey'] = 'ontario-badge--neutral-light';
	BadgeColourToClass['red'] = 'ontario-badge--alert-heavy';
	BadgeColourToClass['yellow'] = 'ontario-badge--warning-heavy';
	BadgeColourToClass['green'] = 'ontario-badge--success-heavy';
	BadgeColourToClass['white'] = 'ontario-badge--white';
	BadgeColourToClass['darkGrey'] = 'ontario-badge--grey';
})(BadgeColourToClass || (BadgeColourToClass = {}));
const BadgeColours = retrieveEnumKeys(BadgeColourToClass);

const ontarioBadgeCss =
	'.ontario-badge__container{display:flex;flex-direction:column;gap:2.5rem;align-items:flex-start;padding:1.5rem 1rem}.ontario-badge__label{display:block;text-align:left;font-weight:600;margin-bottom:0.75rem;font-size:0.875rem;color:#4d4d4d}.ontario-badge{display:inline-block;background-color:#E2F0F4;color:#4d4d4d;padding:0.25rem 0.5rem;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:700;line-height:1.5625rem;letter-spacing:0.03rem;text-transform:uppercase}.ontario-badge--default-light{background-color:#E2F0F4;color:#4d4d4d}.ontario-badge--default-heavy{background-color:#1080A6;color:#FFFFFF}.ontario-badge--neutral-light{background-color:#f2f2f2;color:#4d4d4d}.ontario-badge--neutral-heavy{background-color:#1a1a1a;color:#FFFFFF}.ontario-badge--alert-heavy{background-color:#CD0000;color:#FFFFFF}.ontario-badge--warning-heavy{background-color:#FFD440;color:#1a1a1a}.ontario-badge--success-heavy{background-color:#118847;color:#FFFFFF}.ontario-badge--white{background-color:#FFFFFF;color:#4d4d4d;border:0.0625rem solid #4d4d4d}.ontario-badge--grey{background-color:#cccccc;color:#1a1a1a}';

const OntarioBadge = /*@__PURE__*/ proxyCustomElement(
	class OntarioBadge extends HTMLElement {
		constructor() {
			super();
			this.__registerHost();
			this.__attachShadow();
		}
		get host() {
			return this;
		}
		internals;
		/**
		 * The colour of the badge.
		 */
		colour = 'teal';
		/**
		 * The label for the badge.
		 *
		 * Offical guidance is to keep the label length within 15 characters.
		 */
		label;
		/**
		 * An aria label for screen readers.
		 *
		 * Used to provide more context to screen readers if necessary.
		 *
		 * This property is optional.
		 *
		 * @example
		 * <ontario-badge aria-label-text="This training is currently in progress.">In progress</ontario-badge>
		 */
		ariaLabelText;
		/**
		 * Watch for changes in the `label` prop for validation purposes.
		 *
		 * If no `label` value or host.textContent is provided, a warning message will be printed.
		 */
		validateLabel() {
			if (!this.getBadgeLabel()) {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' a label ')
					.addRegularText('for')
					.addMonospaceText(' <ontario-badge> ')
					.addRegularText('was not provided.')
					.printMessage();
			}
		}
		/**
		 * Watch for changes to the `colour` prop.
		 *
		 * If no `colour` is passed, or if the `colour` does not match the `colour` options, a default value of 'teal' will be applied.
		 *
		 * @returns {BadgeColour}
		 */
		validateColour() {
			if (this.colour) {
				if (validateValueAgainstArray(this.colour, BadgeColours)) {
					return this.colour;
				} else {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(` colour ${this.colour} `)
						.addRegularText('for')
						.addMonospaceText(' <ontario-badge> ')
						.addRegularText('does not match one of the valid colour types. A default colour of `teal` will be applied.')
						.printMessage();
				}
			}
			return this.setBadgeColour('teal');
		}
		/**
		 * Programatically set and return the colour prop.
		 *
		 * @prop {BadgeColour} colour
		 *
		 * @returns {BadgeColour}
		 */
		setBadgeColour(colour) {
			this.colour = colour;
			return this.colour;
		}
		/**
		 * Returns badge label depending on if the label prop was set or
		 * if the host.textContent (text in-between the opening and closing tag) was set.
		 *
		 * The label prop takes priority.
		 *
		 * @returns {string | null}
		 */
		getBadgeLabel() {
			const badgeLabel = this.label ? this.label : this.host.textContent;
			return badgeLabel;
		}
		componentWillLoad() {
			this.validateColour();
			this.validateLabel();
		}
		render() {
			return h(
				'span',
				{
					'key': '9fec2518bba42350d3bb2f744ae831d0bbc73265',
					'class': `ontario-badge ${BadgeColourToClass[this.colour]}`,
					'aria-label': this.ariaLabelText,
				},
				this.getBadgeLabel(),
			);
		}
		static get watchers() {
			return {
				label: ['validateLabel'],
				colour: ['validateColour'],
			};
		}
		static get style() {
			return ontarioBadgeCss;
		}
	},
	[
		1,
		'ontario-badge',
		{
			colour: [1025],
			label: [1],
			ariaLabelText: [1025, 'aria-label-text'],
		},
		undefined,
		{
			label: ['validateLabel'],
			colour: ['validateColour'],
		},
	],
);
function defineCustomElement() {
	if (typeof customElements === 'undefined') {
		return;
	}
	const components = ['ontario-badge'];
	components.forEach((tagName) => {
		switch (tagName) {
			case 'ontario-badge':
				if (!customElements.get(tagName)) {
					customElements.define(tagName, OntarioBadge);
				}
				break;
		}
	});
}

export { OntarioBadge as O, defineCustomElement as d };
//# sourceMappingURL=ontario-badge2.js.map

//# sourceMappingURL=ontario-badge2.js.map
