import { h } from '@stencil/core';
import { BadgeColours, BadgeColourToClass } from './ontario-badge.types';
import { ConsoleMessageClass } from '../../utils/console-message/console-message';
import { validateValueAgainstArray } from '../../utils/validation/validation-functions';
export class OntarioBadge {
	host;
	internals;
	/**
	 * The colour of the badge.
	 */
	colour = 'teal';
	/**
	 * The label for the badge.
	 *
	 * Offical guidance is to keep the label length within 15 characters.
	 */
	label;
	/**
	 * An aria label for screen readers.
	 *
	 * Used to provide more context to screen readers if necessary.
	 *
	 * This property is optional.
	 *
	 * @example
	 * <ontario-badge aria-label-text="This training is currently in progress.">In progress</ontario-badge>
	 */
	ariaLabelText;
	/**
	 * Watch for changes in the `label` prop for validation purposes.
	 *
	 * If no `label` value or host.textContent is provided, a warning message will be printed.
	 */
	validateLabel() {
		if (!this.getBadgeLabel()) {
			const message = new ConsoleMessageClass();
			message
				.addDesignSystemTag()
				.addMonospaceText(' a label ')
				.addRegularText('for')
				.addMonospaceText(' <ontario-badge> ')
				.addRegularText('was not provided.')
				.printMessage();
		}
	}
	/**
	 * Watch for changes to the `colour` prop.
	 *
	 * If no `colour` is passed, or if the `colour` does not match the `colour` options, a default value of 'teal' will be applied.
	 *
	 * @returns {BadgeColour}
	 */
	validateColour() {
		if (this.colour) {
			if (validateValueAgainstArray(this.colour, BadgeColours)) {
				return this.colour;
			} else {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(` colour ${this.colour} `)
					.addRegularText('for')
					.addMonospaceText(' <ontario-badge> ')
					.addRegularText('does not match one of the valid colour types. A default colour of `teal` will be applied.')
					.printMessage();
			}
		}
		return this.setBadgeColour('teal');
	}
	/**
	 * Programatically set and return the colour prop.
	 *
	 * @prop {BadgeColour} colour
	 *
	 * @returns {BadgeColour}
	 */
	setBadgeColour(colour) {
		this.colour = colour;
		return this.colour;
	}
	/**
	 * Returns badge label depending on if the label prop was set or
	 * if the host.textContent (text in-between the opening and closing tag) was set.
	 *
	 * The label prop takes priority.
	 *
	 * @returns {string | null}
	 */
	getBadgeLabel() {
		const badgeLabel = this.label ? this.label : this.host.textContent;
		return badgeLabel;
	}
	componentWillLoad() {
		this.validateColour();
		this.validateLabel();
	}
	render() {
		return h(
			'span',
			{
				'key': '9fec2518bba42350d3bb2f744ae831d0bbc73265',
				'class': `ontario-badge ${BadgeColourToClass[this.colour]}`,
				'aria-label': this.ariaLabelText,
			},
			this.getBadgeLabel(),
		);
	}
	static get is() {
		return 'ontario-badge';
	}
	static get encapsulation() {
		return 'shadow';
	}
	static get originalStyleUrls() {
		return {
			$: ['ontario-badge.scss'],
		};
	}
	static get styleUrls() {
		return {
			$: ['ontario-badge.css'],
		};
	}
	static get properties() {
		return {
			colour: {
				type: 'string',
				attribute: 'colour',
				mutable: true,
				complexType: {
					original: 'BadgeColour',
					resolved: '"black" | "darkGrey" | "green" | "grey" | "lightTeal" | "red" | "teal" | "white" | "yellow"',
					references: {
						BadgeColour: {
							location: 'import',
							path: './ontario-badge.types',
							id: 'src/components/ontario-badge/ontario-badge.types.ts::BadgeColour',
						},
					},
				},
				required: false,
				optional: false,
				docs: {
					tags: [],
					text: 'The colour of the badge.',
				},
				getter: false,
				setter: false,
				reflect: false,
				defaultValue: "'teal'",
			},
			label: {
				type: 'string',
				attribute: 'label',
				mutable: false,
				complexType: {
					original: 'string',
					resolved: 'string',
					references: {},
				},
				required: false,
				optional: false,
				docs: {
					tags: [],
					text: 'The label for the badge.\n\nOffical guidance is to keep the label length within 15 characters.',
				},
				getter: false,
				setter: false,
				reflect: false,
			},
			ariaLabelText: {
				type: 'string',
				attribute: 'aria-label-text',
				mutable: true,
				complexType: {
					original: 'string',
					resolved: 'string | undefined',
					references: {},
				},
				required: false,
				optional: true,
				docs: {
					tags: [
						{
							name: 'example',
							text: '<ontario-badge aria-label-text="This training is currently in progress.">In progress</ontario-badge>',
						},
					],
					text: 'An aria label for screen readers.\n\nUsed to provide more context to screen readers if necessary.\n\nThis property is optional.',
				},
				getter: false,
				setter: false,
				reflect: false,
			},
		};
	}
	static get elementRef() {
		return 'host';
	}
	static get watchers() {
		return [
			{
				propName: 'label',
				methodName: 'validateLabel',
			},
			{
				propName: 'colour',
				methodName: 'validateColour',
			},
		];
	}
	static get attachInternalsMemberName() {
		return 'internals';
	}
}
//# sourceMappingURL=ontario-badge.js.map
